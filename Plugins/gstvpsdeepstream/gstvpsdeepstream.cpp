/*
 * Milestone:
 * This file was generated by GStreamer's make_template script.
 * This plugin uses Nvidia DeepStream to detect and classify objects and creates
 * bounding boxes around the objects in Onvif format.
 *
 * GStreamer
 * Copyright (C) 2005 Thomas Vander Stichele <thomas@apestaart.org>
 * Copyright (C) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
 * Copyright (C) 2019  <<user@hostname.org>>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Alternatively, the contents of this file may be used under the
 * GNU Lesser General Public License Version 2.1 (the "LGPL"), in
 * which case the following provisions apply instead of the ones
 * mentioned above:
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

 /**
  * SECTION:element-vpsdeepstream
  *
  * This element uses Nvidia DeepStream to detect and classify objects and creates
  * bounding boxes around the objects in Onvif format.
  *
  * <refsect2>
  * <title>Example launch line</title>
  * |[
  * gst-launch -v -m fakesrc ! vpsdeepstream ! fakesink
  * ]|
  * </refsect2>
  */

#include <sstream>
#include <gst/gst.h>
#include <chrono>
#include "gstvpsdeepstream.h"
#include "gstnvdsmeta.h"
#include "nvdsmeta.h"


GST_DEBUG_CATEGORY_STATIC(gst_vpsdeepstream_debug);
#define GST_CAT_DEFAULT gst_vpsdeepstream_debug

/* Filter signals and args */
enum
{
  /* FILL ME */
  LAST_SIGNAL
};

enum
{
  PROP_0
};

#define gst_vpsdeepstream_parent_class parent_class
G_DEFINE_TYPE(GstVpsDeepStream, gst_vpsdeepstream, GST_TYPE_BIN);

static void gst_vpsdeepstream_set_property(GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec);
static void gst_vpsdeepstream_get_property(GObject * object, guint prop_id, GValue * value, GParamSpec * pspec);

static gboolean gst_vpsdeepstream_sink_event(GstPad * pad, GstObject * parent, GstEvent * event);
static GstFlowReturn gst_vpsdeepstream_chain(GstPad * pad, GstObject * parent, GstBuffer * buf);

/* GObject vmethod implementations */

/* initialize the vpsdeepstream's class */
static void gst_vpsdeepstream_class_init(GstVpsDeepStreamClass * klass)
{
  GObjectClass *gobject_class;
  GstElementClass *gstelement_class;

  gstelement_class = (GstElementClass *)klass;

  gst_element_class_set_details_simple(gstelement_class,
    "vpsdeepstream",
    "VPS/test",
    "Attaches gstvpsonvifmeta to the buffer containing a bounding box in Onvif format",
    "developer.milestonesys.com");
}

/* initialize the new elements
 * instantiate pads and add them to element
 * set pad calback functions
 * initialize instance structure
 */
static void gst_vpsdeepstream_init(GstVpsDeepStream * filter)
{
  /* Create the xprotect element to remove generic byte data headers from the video frames */
  filter->header_remover = gst_element_factory_make("fromxprotectconverter", "header_remover");
  if (!filter->header_remover)
  {
    GST_ERROR("Failed to create header_remover element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created fromxprotectconverter element.");
  }

  /* Create queues for each of the src pads of fromxprotectconverter */
  filter->queue_video = gst_element_factory_make("queue", "queue_video");
  if (!filter->queue_video)
  {
    GST_ERROR("Failed to create video queue element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created video queue element.");
  }

  filter->queue_meta = gst_element_factory_make("queue", "queue_meta");
  if (!filter->queue_meta)
  {
    GST_ERROR("Failed to create meta queue element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created meta queue element.");
  }

  /* Since we don't need the metadata information coming from fromxprotectconverter,
     we just stuff it into a fake sink. */
  filter->fake_sink = gst_element_factory_make("fakesink", "fake_sink");
  if (!filter->fake_sink)
  {
    GST_ERROR("Failed to create fakesink element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created fakesink element.");
  }

  filter->parser = gst_element_factory_make("h264parse", "parser");
  if (!filter->parser)
  {
    GST_ERROR("Failed to create parser element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created parser element.");
  }

  filter->decode = gst_element_factory_make("nvv4l2decoder", "decode");
  if (!filter->decode)
  {
    GST_ERROR("Failed to create decode element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created decode element.");
  }

  filter->muxer = gst_element_factory_make("nvstreammux", "muxer");
  if (!filter->muxer)
  {
    GST_ERROR("Failed to create muxer element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created muxer element.");
  }
  g_object_set(G_OBJECT(filter->muxer), "width", 1280, "height",
    720, "batch-size", 1,
    "batched-push-timeout", 4000000,
    "live-source", 1, NULL);

  filter->inference = gst_element_factory_make("nvinfer", "inference");
  if (!filter->inference)
  {
    GST_ERROR("Failed to create inference element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created inference element.");
  }

  g_object_set(G_OBJECT(filter->inference),
    "config-file-path", "/opt/nvidia/deepstream/deepstream-4.0/samples/configs/deepstream-app/config_infer_primary.txt",
    "unique-id", 1,
    NULL);

  filter->tracker = gst_element_factory_make("nvtracker", "tracker");
  if (!filter->tracker)
  {
    GST_ERROR("Failed to create tracker element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created tracker element.");
  }

  g_object_set(G_OBJECT(filter->tracker),
    "gpu-id", 0,
    "ll-config-file", "/opt/nvidia/deepstream/deepstream-4.0/samples/configs/deepstream-app/tracker_config.yml",
    "ll-lib-file", "libnvds_nvdcf.so",
    NULL);

  filter->boundingbox = gst_element_factory_make("nvdstoonvif", "boundingbox");
  if (!filter->boundingbox)
  {
    GST_ERROR("Failed to create boundingbox element.");
    return;
  }
  else
  {
    GST_INFO("Successfully created boundingbox element.");
  }
  /* We don't want to return video from the bounding box plugin, as the video will be raw and won't be usable by XProtect. */
  g_object_set(G_OBJECT(filter->boundingbox),
    "return_video", 0, NULL);

  gst_bin_add_many((GstBin *)filter, filter->header_remover, NULL);
  gst_bin_add_many((GstBin *)filter, filter->queue_video, NULL);
  gst_bin_add_many((GstBin *)filter, filter->queue_meta, NULL);
  gst_bin_add_many((GstBin *)filter, filter->fake_sink, NULL);
  gst_bin_add_many((GstBin *)filter, filter->parser, NULL);
  gst_bin_add_many((GstBin *)filter, filter->decode, NULL);
  gst_bin_add_many((GstBin *)filter, filter->muxer, NULL);
  gst_bin_add_many((GstBin *)filter, filter->inference, NULL);
  gst_bin_add_many((GstBin *)filter, filter->tracker, NULL);
  gst_bin_add_many((GstBin *)filter, filter->boundingbox, NULL);

  /* Because header_remover has two different src pads, we need to link these statically with both queues */
  GstPadLinkReturn ret;
  GstPad *src_pad = gst_element_get_static_pad(filter->header_remover, "src_metadata");
  GstPad *sink_pad = gst_element_get_static_pad(filter->queue_meta, "sink");
  ret = gst_pad_link(src_pad, sink_pad);

  if (GST_PAD_LINK_FAILED(ret))
  {
    GST_ERROR("Failed to link header_remover with queue_meta.");
    return;
  }
  else
  {
    GST_INFO("Successfully linked header_remover with queue_meta.");
  }

  src_pad = gst_element_get_static_pad(filter->header_remover, "src_video");
  sink_pad = gst_element_get_static_pad(filter->queue_video, "sink");
  ret = gst_pad_link(src_pad, sink_pad);
  if (GST_PAD_LINK_FAILED(ret))
  {
    GST_ERROR("Failed to link header_remover with queue_video.");
    return;
  }
  else
  {
    GST_INFO("Successfully linked header_remover with queue_video.");
  }

  gst_object_unref(src_pad);
  gst_object_unref(sink_pad);

  /* We need to add a ghost pad to the header_remover sink */
  GstPad *ghostpadsink = gst_element_get_static_pad(filter->header_remover, "sink");
  if (!ghostpadsink)
  {
    GST_ERROR("Could not find '%s' in '%s'", "sink", "filter->header_remover");
    return;
  }
  gst_element_add_pad((GstElement *)filter, gst_ghost_pad_new("sink", ghostpadsink));
  gst_object_unref(ghostpadsink);
  GST_INFO("Successfully added sink ghost pad (header_remover).");

  /* We need to add a ghost pad to the boundingbox src */
  GstPad *ghostpadsrc = gst_element_get_static_pad(filter->boundingbox, "src");
  if (!ghostpadsrc)
  {
    GST_ERROR("Could not find '%s' in '%s'", "src", "filter->boundingbox");
  }
  gst_element_add_pad((GstElement *)filter, gst_ghost_pad_new("src", ghostpadsrc));
  gst_object_unref(ghostpadsrc);
  GST_INFO("Successfully added src ghost pad (boundingbox).");

  /* We need to add a fake sink to the queue_meta (we don't care about the xprotect metadata). */
  if (gst_element_link(filter->queue_meta, filter->fake_sink) != TRUE)
  {
    GST_ERROR("Elements could not be linked in vpsdeepstream plugin: queue_meta and fake_sink.");
    return;
  }
  GST_INFO("Successfully linked queue_meta with fake_sink.");

  /* Link the queue_video to the parser */
  if (gst_element_link(filter->queue_video, filter->parser) != TRUE)
  {
    GST_ERROR("Elements could not be linked in vpsdeepstream plugin: queue_video and parser\n");
    return;
  }
  GST_INFO("Successfully linked queue_video with parser.");

  /* Link the parser to the decoder */
  if (gst_element_link(filter->parser, filter->decode) != TRUE)
  {
    GST_ERROR("Elements could not be linked in vpsdeepstream plugin: parser and decode.");
    return;
  }
  GST_INFO("Successfully linked parser with decode.");

  /* Link decoder to muxer */
  GstPad *sinkpad, *srcpad;
  gchar pad_name_sink[16] = "sink_0";
  gchar pad_name_src[16] = "src";

  sinkpad = gst_element_get_request_pad(filter->muxer, pad_name_sink);
  if (!sinkpad)
  {
    GST_ERROR("Muxer request sink pad failed.");
    return;
  }

  srcpad = gst_element_get_static_pad(filter->decode, pad_name_src);
  if (!srcpad)
  {
    GST_ERROR("Decoder request src pad failed.");
    return;
  }

  if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)
  {
    GST_ERROR("Failed to link decoder to stream muxer.");
    return;
  }

  if (gst_element_link(filter->muxer, filter->inference) != TRUE)
  {
    GST_ERROR("Elements could not be linked in vpsdeepstream plugin: muxer and inference.");
    return;
  }
  GST_INFO("Successfully linked muxer with inference.");

  if (gst_element_link(filter->inference, filter->tracker) != TRUE)
  {
    GST_ERROR("Elements could not be linked in vpsdeepstream plugin: inference and tracker.");
    return;
  }
  GST_INFO("Successfully linked inference with tracker.");

  if (gst_element_link(filter->tracker, filter->boundingbox) != TRUE)
  {
    GST_ERROR("Elements could not be linked in vpsdeepstream plugin: tracker and boundingbox.");
    return;
  }
  GST_INFO("Successfully linked tracker with boundingbox.");
}

/* GstElement vmethod implementations */

/* this function handles sink events */
static gboolean gst_vpsdeepstream_sink_event(GstPad * pad, GstObject * parent, GstEvent * event)
{
  GstVpsDeepStream *filter;
  gboolean ret;

  filter = GST_VPSDEEPSTREAM(parent);

  GST_LOG_OBJECT(filter, "Received %s event: %" GST_PTR_FORMAT,
    GST_EVENT_TYPE_NAME(event), event);

  switch (GST_EVENT_TYPE(event)) {
  case GST_EVENT_CAPS:
  {
    GstCaps * caps;

    gst_event_parse_caps(event, &caps);
    /* do something with the caps */

    /* and forward */
    ret = gst_pad_event_default(pad, parent, event);
    break;
  }
  default:
    ret = gst_pad_event_default(pad, parent, event);
    break;
  }
  return ret;
}

/* entry point to initialize the plug-in
 * initialize the plug-in itself
 * register the element factories and other features
 */
static gboolean vpsdeepstream_init(GstPlugin * vpsdeepstream)
{
  /* debug category for fltering log messages
   *
   * exchange the string 'Template vpsdeepstream' with your description
   */
  GST_DEBUG_CATEGORY_INIT(gst_vpsdeepstream_debug, "vpsdeepstream",
    0, "Template vpsdeepstream");

  return gst_element_register(vpsdeepstream, "vpsdeepstream", GST_RANK_NONE,
    GST_TYPE_VPSDEEPSTREAM);
}


/* PACKAGE: this is usually set by autotools depending on some _INIT macro
 * in configure.ac and then written into and defined in config.h, but we can
 * just set it ourselves here in case someone doesn't use autotools to
 * compile this code. GST_PLUGIN_DEFINE needs PACKAGE to be defined.
 */
#ifndef PACKAGE
#define PACKAGE "gst-vps-test"
#endif

#ifndef PACKAGE_VERSION
#define PACKAGE_VERSION "1.0"
#endif

#ifndef GST_PACKAGE_NAME
#define GST_PACKAGE_NAME "VPS Gstreamer test plugin package"
#endif

#ifndef GST_PACKAGE_ORIGIN
#define GST_PACKAGE_ORIGIN "Milestone Systems"
#endif

#ifndef GST_LICENSE
#define GST_LICENSE "LGPL"
#endif


 /* gstreamer looks for this structure to register vpsdeepstreams */
GST_PLUGIN_DEFINE(
  GST_VERSION_MAJOR,
  GST_VERSION_MINOR,
  vpsdeepstream,
  "This plugin uses Nvidia DeepStream to detect and classify objects and creates bounding boxes around the objects in Onvif format.",
  vpsdeepstream_init,
  PACKAGE_VERSION,
  GST_LICENSE,
  GST_PACKAGE_NAME,
  GST_PACKAGE_ORIGIN
)
